# 인터페이스는 구현하는 쪽을 생각해 설계하라

자바 8 전에는 기존 구현체를 깨뜨리지 않고는 인터페이스에 메서드를 추가할 방법이 없었다. 자바 8에서 디폴트 메서드가 생기긴 했지만 위험이 완전히 사라진 것은 아니다.

## 디폴트 메서드를 추가했을 때의 문제점

1. 인터페이스에 디폴트 메서드를 추가하면, 그 인터페이스를 구현한 클래스는 아무것도 모른채 디폴트 메서드가 무작정 '삽입'되게 될 것이다.

 디폴트 메서드를 선언하면, 그 인터페이스를 구현한 후 디폴트 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현이 쓰이게 된다. 하지만 이 방법이 매끄럽게 연동되리라는 보장은 없다. 자바 7까지는 모든 클래스가 현재 인터페이스에 새로운 메서드가 추가되는 일이 없다는 가정으로 작성됐기 때문이다. 

2. 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어렵다.

자바 8에서는 핵심 컬렉션 인터페이스들에 다수의 디폴트 메서드가 추가되었다. 주로 람다를 활용하기 위해서다. 자바 라이브러리의 디폴트 메서드는 대부분 상황에서는 잘 작동한다. 하지만 모든 상황에서 그렇다고 하기는 어렵다.

``` java
default boolean removeIf(Predicate<? super E> filter) {
    Ojbects.requireNonNull(filter);
    boolean result = false;
    for (Iterator<E> it = iterator(); it.hasNext();) {
        if (filter.test(it.next())) {
            it.remove();
            result = true;
        }
    }
    return result;
}
```

자바 8의 `Collection` 인터페이스에 추가된 `removeIf` 메서드이다. 이 메서드는 주어진 불리언 함수가 `true`를 반환하는 모든 원소를 제거한다. 디폴트 구현은 반복자를 이용해 순회하며 각 원소를 인수로 넣어 프레디키트를 호출해 제거하는 방식을 하고 있다.

이 코드보다 더 범용적인 구현을 하기는 어렵지만 그렇다고해서 모든 `Collection` 구현체와 어울리는 것은 아니다. 

`org.apache.commons.collections4.collection.SynchronizedCollection` 클래스는 `java.util`의 `Collections.synchronizedCollection` 정적 팩터리 메서드가 반환하는 클래스와 비슷하다. 아파치 버전은 클라이언트가 제공한 객체로 락을 거는 능력을 추가로 제공한다. 즉, 모든 메서드에서 주어진 락 객체로 동기화한 후 내부 컬렉션 객체에 기능을 위임하는 래퍼 클래스([아이템 18](https://github.com/javabara/effective-java/blob/main/4/18.md))다. 이 클래스는 지금도 활용되고 있지만 `removeIf`를 재정의하지 않고 있다. 이 클래스를 자바 8과 함께 사용하게 된다면, 모든 메서드 호출을 알아서 동기화 할 수 없게된다. `removeIf`는 동기화에 관해 아무것도 모르기 때문에 락 객체를 사용할 수 없다. 따라서 `removeIf`를 호출했을 때 문제가 생길 수 있다.

이 문제를 해결하기 위해 일련의 조치를 취했다. 구현한 인터페이스의 디폴트 메서드를 재정의하고, 다른 메서드에서는 디폴트 메서드를 호출하기 전에 필요한 작업을 수행하도록 했다. 하지만 자바 플랫폼에 속하지 않는 기존의 컬렉션 구현체는 이런 언어 차원의 변화에 맞춰 수정할 기회가 없었고, 일부는 여전히 수정되지 않았다.

3. 디폴트 메서드는 기존 구현체에 런타임 오류를 일으킬 수 있다.

다음과 같은 이유들 때문에 기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니라면 피해야한다. 하지만 새로운 인터페이스를 만드는 경우라면 아주 유용한 수단이고 더 쉽게 구현해 활용할 수 있게끔 해준다. ([아이템 20](https://github.com/javabara/effective-java/blob/main/4/20.md))

## 유의 사항

1. 디폴트 메서드는 인터페이스로부터 메서드를 제거하거나 기존 메서드의 시그니처를 수정하는 용도가 아니다.
2. 디폴트 메서드라는 도구가 생겨도 인터페이스 설계는 세심한 주의를 기울여야 한다.
    - 디폴트 메서드로 기존 인터페이스에 새로운 메서드를 추가하면 위험하다.
    - 이는 예측 불가능한 오류를 일으킬 수 있다.
3. 새로운 인터페이스라면 릴리스 전에 반드시 테스트를 거쳐야 한다.
    - 인터페이스를 릴리스한 후에도 결함을 수정하는게 가능한 경우도 있겠지만, 절대 그 가능성에 기대서는 안 된다.