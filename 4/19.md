# 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

## 상속을 고려한 설계와 문서화

메서드를 재정의하면 어떤 일이 일어나는지 정확히 정리하여 문서로 남겨야한다. 즉 클래스는 재정의할 수 있는 메서드를 내부적으로 어떻게 이용하는지 문서로 남겨야한다. 클래스 API로 공개된 메서드에서 클래스 자신의 또 다른 메서드를 호출할 수도 있다. 그런데 호출되는 메서드가 재정의 가능 메서드라면 그 사실을 호출하는 메서드의 API 설명에 적시해야 한다. 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지도 담아야 한다. 

API 문서의 메서드 설명 끝에서 종종 "Implementation Requirements"로 시작하는 절을 볼 수 있다. 그 메서드 내부 동작 방식을 설명하는 곳이다. 이 절은 메서드 주석에 `@implSpec`를 붙여주면 자바독 도구가 생성해준다.

```
public boolean remove(Object o)

주어진 원소가 이 컬렉션 안에 있다면 그 인스턴스를 하나 제거한다(선택적 동의). 더 정확하게 말하면, 이 컬렉션 안에 'Object.equals(o, e)가 참인 원소' e가 하나 이상 있다면 그중 하나를 제거한다. 주어진 원소가 컬렉션 안에 있었다면(즉, 호출 결과 이 컬렉션이 변경됐다면) true를 반환한다.
Implementation Requirements: 이 메서드는 컬렉션을 순회하며 주어진 원소를 찾도록 구현되었다. 주어진 원소를 찾으면 반복자의 remove 메서드를 사용해 컬렉션에서 제거한다. 이 컬렉션이 주어진 객체를 갖고 있으나, 이 컬렉션의 iterator 메서드가 반환한 반복자가 remove 메서드를 구현하지 않았다면 UnsupportedOperationException을 던지니 주의하자.
```

하지만 좋은 API란 어떻게가 아닌 무엇을 설명해야한다. 하지만 이는 상속이 캡슐화를 해치기 때문에 안전하게 상속할 수 있도록 하려면 내부 구현을 어떻게하는지 설명해야만 하기 때문이다.  

## 상속을 허용하는 클래스가 지켜야 할 제약

1. 어쨋든 내부 메커니즘을 문서로 남기는 것만이 상속을 위한 설계의 전부는 아니다. 효율적인 하위 클래스를 큰 어려움 없이 만들려면 클래스 내부 동작 과정 중간에 끼어들 수 있는 훅을 잘 선별하여 `protected` 메서드 형태로 공개해야 할 수도 있다.

예를들어서 `List` 구현체의 사용자는 `removeRange` 메서드에 관심 없다. 그럼에도 메서드를 제공하는 단지 하위 클래스에서 부분리스트의 `clear` 메서드를고성능으로 만들기 쉽게 하기 위해서다. 따라서 `removeRange` 메서드를 `protected`로 공개한다.

그렇다면 어떤 메서드를 `protected`로 노출해야할지는 어떻게 정할까? 

결정하는 방법은 잘 예측한 다음, 실제 하위 클래스를 만들어 시험해보는 것이 최선이다. 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어 시험하는 것이 유일하다. 하위 클래스를 여러개 만들때 까지 전혀 쓰이지 않는 `protected` 멤버는 사실 `private` 였어야할 가능성이 크다. 

2. 상속용 클래스의 생성자는 직접적이든 간접적이든 재정의 가능 메서드를 호출해서는 안 된다.

상위 클래스 생성자가 하위 클래스 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다. 이때 그 재정의한 매서드가 하위 클래스의 생성자에서 초기화하는 값에 의존하면 제대로 작동하지 않을 것이다.

``` java
public class Super {
    public Super() {
        overrideMe();
    }

    public void overrideMe() { ... }
}

public final class Sub extends Super {
    Sub() {
        instant = Instant.now();
    }

    @Override
    public void overrideMe() {
        System.out.println(instant);
    }

    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}
```

이 예제에서 `instant`를 두 번 출력을 기대하겠지만, 첫 번째는 `null`을 출력한다. 상위 클래스의 생성자가 하위 클래스 인스턴스 필드를 초기화 하기도 전에 `overrideMe`를 호출하기 때문이다.

3. `clone`과 `readobject` 모두 직접적이든 간접적이든 재정의 가능 메서드를 호출해서는 안 된다.

`clone`과 `readObject` 메서드는 생성자와 비슷한 효과를 낸다. 따라서 상속용 클래스에서 `Cloneable`이나 `Serializable`을 구현할지 정해야 한다면, 이들을 구현할 때 따르는 제약도 생성자도 비슷하다는 점을 주의해야한다.

`readObject`는 하위 클래스의 상태가 역직렬화되기 전에 재정의한 메서드부터 호출하게된다. `clone`의 경우 하위 클래스의 `clone` 메서드가 복사한 객체의 상태를 수정하기 전에 재정의한 메서드를 호출한다. 

4. `Serializable`을 구현한 상속용 클래스가 `readResolve`나 `writeReplace` 메서드를 갖는다면 이 메서드들은 `private`으로 선언한다면 하위 클래스에서 무시되기 때문이다.

### 제약을 해결하는 가장 좋은 방법

상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이 가장 좋은 해결책이다. 상속을 금지하는 방법은 두가지가 있다. 

1. 클래스를 `final`로 선언한다.
2. 모든 생성자를 `private`이나 `package-private`으로 선언하고 `public` 정적 팩터리를 만들어주는 방법이다.

### 상속을 허용하는 합당한 방법

구체 클래스가 표준 인터페이스를 구현하지 않았는데 상속을 금지한다면 사용하기 상당히 불편해진다. 그래서 이런 클래스를 상속을 허용해야겠다면 합당한 방법이 하나 있다. 클래스 내부에서 재정의 가능 메서드를 사용하지 않도록 만들고 이 사실을 문서화하는 것이다.

### 재정의 가능 메서드를 사용하는 코드 제거하는 방법

각각의 재정의 가능 메서드는 자신의 본문 코드를 `private` '도우미 메서드'로 옮기고, 이 도우미 메서드를 호출하도록 수정한다. 그런 다음 재정의 가능 메서드를 호출하는 다른 코드들도 모두 이 도우미 메서드를 직접 호출하도록 수정하면 된다.

## 핵심 정리
상속용 클래스를 설계하는 것은 쉽지가 않다. 클래스 내부에서 스스로를 어떻게 사용하는지(자기사용 패턴) 모두 문서로 남겨야하고, 일단 문서화한 것은 반드시 지켜야한다. 그렇지 않으면 이 문서화를 믿고 만든 하위 클래스에서 문제가 생긴다. 다른 사람이 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 `protected`로 제공해야 할 수도 있다. 그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않다면 상속을 금지하는 편이 낫다. 상속을 금지하려면 클래스를 `final`로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 된다.