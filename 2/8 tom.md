# finalizer와 cleaner 사용을 피하라

자바에는 두 가지 객체 소멸자를 제공하지만 예측하기 어렵고, 느리고, 불필요하다. (`finalizer`의 경우 자바 9에서 deprecated 되었다.) 자바는 접근할 수 없게 된 객체를 회수하는 역할을 GC가 담당하며 비메모리 자원을 회수하는 용도는 `try-with-resources`와 `try-finally`를 사용해 해결한다.([아이템 9](https://github.com/javabara/effective-java/blob/main/2/9.md))

## 사용하지 말아야하는 이유

1. `finalizer`와 `cleaner`로는 제때 실행되어야 하는 작업을 절대 할 수 없다.
    - `finalizer`와 `cleaner`는 **즉시 수행된다는 보장이 없다.**
    - 만약 파일 닫기를 `finalizer`와 `cleaner`가 담당하게 된다면 제때 파일 닫기를 하지 않아 파일을 계속 열어두게되어 새로운 파일을 열지 못해 프로그램이 실패할 수도 있다.

2. 수행 시점 뿐 아니라 **수행 여부조차 보장하지 않는다.**
    - 접근할 수 없는 일부 객체의 종료 작업을 전혀 수행하지 못한 채 프로그램이 중단될 수도 있다.

따라서 프로그램 생애주기와 상관없는, **상태를 영구적으로 수정하는 작업에서는 절대 `finalizer`나 `cleaner`에 의존해서는 안된다.**

> `System.gc`나 `System.runFinalization` 메서드에 현혹되지 말자. `finalizer`와 `cleaner`가 실행될 가능성을 높여줄 수는 있으나, 보장해주진 않는다. 사실 보장해주는 메서드가 2개 있긴했다. 바로 `System.runFinalizerOnExit`과 그 쌍둥이인 `Runtime.runFinalizersOnExit`이다. 하지만 이 두메서드는 심각한 오류를 가지고 있어 사용하지 않는다.

3. `finalizer` 동작 중 발생한 예외는 무시되며, 처리할 작업이 남았더라도 그 순간 종료된다.
    - 잡지 못한 예외로 인해 해당 객체는 마무리가 덜 된 상태로 남을 수도 있다.
    - 그나마 `cleaner`를 사용하는 라이브러리는 자신의 스레드를 통제하기 때문에 이러한 문제가 발생하지 않는다.

4. 심각한 성능 문제
    - GC의 효율을 떨어트리기 때문에 객체 하나를 생성, 정리, 파괴하는데 엄청나게 많은 시간이 걸린다.

5. `finalizer`를 사용하는 클래스는 `finalizer` 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다.
    - 생성자나 직렬화 과정에서 예외가 발생하면, 이 생성되다 만 객체에서 악의적인 하위 클래스의 `finalizer`가 수행될 수 있다.
    - 또한 이 `finalizer`는 정적 필드에 자신의 참조를 할당해 GC가 수집하지 못하게 막을 수 있다. 
    - `final` 클래스들은 하위 클래스를 만들 수 없으니 이 공격에서 안전하다.
    - `final` 클래스가 아닐 경우 아무 일도 하지 않는 `finalize` 메서드를 만들어 `final`로 선언하자.

## `finalizer`나 `cleaner`를 대신해줄 대안, `AutoCloseable`
`AutoCloseable`을 구현하고, 클라이언트에서 인스턴스를 다 쓰고 나면 `close` 메서드를 호출하면 객체를 간단히 종료할 수 있다. (일반적으로 예외가 발생해도 제대로 종료되도록 `try-with-resources`를 사용해야 한다.) `close` 메서드에서 이 객체는 더 이상 유효하지 않음을 필드에 기록하고, 다른 메서드는 이 필드를 검사해서 객체가 닫힌 후 불렷다면 IllegalStateExceiption을 던지도록 구현해야 한다. 

## `finalizer`와 `cleaner`를 써야하는 경우

1. 자원의 소유자가 `close` 메서드를 호출하지 않은 것에 대비한 안전망 역할.
    - `finalizer`나 `cleaner`가 즉시 호출되리라는 보장은 없지만, 클라이언트가 하지 않은 자원 회수를 늦게라도 해주는 것이 아예 안하는 것보단 낫다. 
    - 자바의 경우 `FileInputStream`, `FileOutputStream`, `ThreadPoolExecutor` 가 대표적 예이다.

2. 네이티브 피어와 연결된 객체에서의 사용
    - `native peer`란 일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체를 말한다. 
    - **네이티브 피어는 자바 객체가 아니여서 가비지 컬렉터는 그 존재를 알지 못한다.**
    - 자바 피어를 회수할 때 네이티브 피어도 회수하지 못해서 `finalizer`나 `cleaner`를 사용한다.
    - 단 네이티브 피어가 심각한 자원을 가지지 않고 있고 성능 저하를 감당할 수 있을 경우에만 사용한다.


## 핵심 정리
`cleaner`는 **안정망 역할** 이나 중요하지 않은 **네이티브 자원 회수용** 으로만 사용하자. 물론 이러한 경우에도 **불확실성과 성능 저하에 주의해야 한다.**
